
#include "physical_simulation_app.h"

namespace vulkancraft
{
	PhysicalSimulationApp::PhysicalSimulationApp()
	{
		try
		{
			init_physics_system();
			test_create_dynamic_rigidbody();
		}
		catch (std::exception& e)
		{
			std::cerr << "物理系统初始化失败：" << e.what() << std::endl;
		}

		try
		{
			game_entity_manager_ = GameEntityManager::get_instance(); // 这里已经生成玩家了

			// 得到全局原子指针，这里进行阻塞以等待渲染线程创建完成
			while (glfw_window_ == nullptr)
			{
				glfw_window_ = global_glfw_window_ptr.load(std::memory_order_acquire);
				// std::cout << "物理线程正在试图获取 GLFW 窗口指针，如果持续看到该信息，则 GameWindow 类初始化失败" << std::endl;
			}
		}
		catch (const std::exception& e)
		{
			throw std::runtime_error("某个单例类初始化失败：" + std::string(e.what()));
		}

		update_physical_simulation(); // 计算物理模拟循环
	}

	PhysicalSimulationApp::~PhysicalSimulationApp()
	{
		glfw_window_ = nullptr; // 窗口指针直接设空就行，清除内容的工作在渲染线程内会由 GLFW 自主完成
		clear_physics_system(); // 清理物理系统
	}

	void PhysicalSimulationApp::init_physics_system()
	{
		collision_default_config_ = new btDefaultCollisionConfiguration();
		dispatcher_ = new btCollisionDispatcher(collision_default_config_);
		overlapping_pair_cache_ = new btDbvtBroadphase();
		solver_ = new btSequentialImpulseConstraintSolver();

		dynamics_world_ = new btDiscreteDynamicsWorld
		(
			dispatcher_,
			overlapping_pair_cache_,
			solver_,
			collision_default_config_
		);

		dynamics_world_->setGravity(kGravityVector);// 设置重力

		int thread_nums = std::thread::hardware_concurrency();

		if (thread_nums <= 0)
		{
			std::cout << "无法找到支持多线程运算的硬件" << std::endl;
		}
		else
		{
			dynamics_world_->setNumTasks(thread_nums);
		}
	}

	void PhysicalSimulationApp::clear_physics_system()
	{
		// remove the rigidbodies from the dynamics world and delete them
		for (int i = dynamics_world_->getNumCollisionObjects() - 1; i >= 0; i--)
		{
			btCollisionObject* obj = dynamics_world_->getCollisionObjectArray()[i];
			btRigidBody* body = btRigidBody::upcast(obj);

			if (body && body->getMotionState())
			{
				delete body->getMotionState();
			}

			dynamics_world_->removeCollisionObject(obj);
			delete obj;
		}

		// delete collision shapes
		for (int j = 0; j < collision_shape_array_.size(); j++)
		{
			btCollisionShape* shape = collision_shape_array_[j];
			collision_shape_array_[j] = 0;
			delete shape;
		}

		// delete dynamics world
		delete dynamics_world_;

		// delete solver
		delete solver_;

		// delete broadphase
		delete overlapping_pair_cache_;

		// delete dispatcher
		delete dispatcher_;

		delete collision_default_config_;

		// next line is optional: it will be cleared by the destructor when the array goes out of scope
		collision_shape_array_.clear();
	}

	void PhysicalSimulationApp::update_physical_simulation()
	{
		while (true)
		{
			// 计算追赶时间
			auto current_time = Clock::now(); // 记录现在的时间
			auto elapsed_time = current_time - previous_time_; // 自上一帧以来的经过时间
			previous_time_ = current_time; // 更新上一帧的时间点

			accumulator_ += elapsed_time.count(); // 累计时间差

			// 计算更新时间间隔
			auto current_step = Clock::now(); // 记录现在的时间
			auto elapsed_step = current_step - previous_step_; // 自上一次以来的间隔时间
			previous_step_ = current_step;

			accumulator_step_ += elapsed_step.count(); // 累加间隔时间
			float accumulator_delta_time = static_cast<float>(accumulator_step_) / 1e9f; // 物理间隔高精度纳秒转换回 float 类型，单位为秒

			// if (accumulator_step_ <= kTimeStep) continue; // 大锁：CD 时间没到，放弃追赶更新

			// 追赶更新
			while (accumulator_ >= kTimePerUpdate)
			{
				// std::cout << accumulator_step_ << std::endl;

				if (accumulator_step_ <= kTimeStep) break; // CD 时间没到就不循环

				// ==================== HACK 这下面是物理循环 ==================== //

				// calculate_aabb_collider(); // 两两检测动态物体的 Collider 是否有碰撞

				// 更新 Bullet 3 物理引擎创建的物理世界
				// 如碰撞，触发器等都用这个物理引擎实现
				update_bullet_physics_world();

				// TODO: 更新玩家坐标位置

				// ==================== HACK 这上面是物理循环 ==================== //

				accumulator_ -= kTimePerUpdate; // 更新 accumulator（默认减去 1/60）
				accumulator_step_ = 0.0f; // 重置更新 CD 时间
			}

			// 帧率控制：计算剩余时间并延时
			double excess_time = accumulator_; // 这是累积的超出一个时间步的额外时间
			accumulator_ = std::fmod(accumulator_, kTimePerUpdate); // 更新 accumulator，去除完整的时间步，仅保留余数

			if (excess_time > 0)
			{
				// 如果有完整的时间步被处理掉（excess_time > 0），则不需要额外延时
				// 这里不需要sleep，因为已经在追赶更新中处理了时间
			}
			else
			{
				// 如果没有完整的时间步要处理（ 即 excess_time <= 0），则计算剩余到下一个更新的时间并延时
				double remaining_time = kTimePerUpdate - accumulator_;

				if (remaining_time > 0)
				{
					std::this_thread::sleep_for(std::chrono::duration<double>(remaining_time));
				}
				else
				{
					remaining_time = 0; // 确保 remaining_time 非负，避免潜在的负睡眠时间
				}
			}
		}
	}

	void PhysicalSimulationApp::update_bullet_physics_world()
	{
		for (int i = dynamics_world_->getNumCollisionObjects() - 1; i >= 0; i--)
		{
			btCollisionObject* obj = dynamics_world_->getCollisionObjectArray()[i];
			btRigidBody* body = btRigidBody::upcast(obj);
			btTransform trans;

			if (body && body->getMotionState())
			{
				body->getMotionState()->getWorldTransform(trans);
			}
			else
			{
				trans = obj->getWorldTransform();
			}

			// printf("world pos object %d = %f,%f,%f\n", i, float(trans.getOrigin().getX()), float(trans.getOrigin().getY()), float(trans.getOrigin().getZ()));
		}
	}

#pragma region 物理游戏对象创建用函数

	void PhysicalSimulationApp::create_single_physics_block(PhysicsObjectCreateData data)
	{
		std::lock_guard<std::mutex> lock(this->collision_shape_array_mutex_);

		// TODO: 用 map 记录这个游戏对象
		btCollisionShape* single_block = new btBoxShape(data.obj_size); // 确定大小

		// TODO: 这里访问不到
		this->collision_shape_array_.push_back(single_block);

		data.transform.setIdentity();
		bool is_dynamic = (data.mass != 0.0f);

		// 如果是动态物体，设置受力张量矩阵
		if (is_dynamic) single_block->calculateLocalInertia(data.mass, data.local_inertia);

		data.transform.setOrigin(data.obj_origin);

		btDefaultMotionState* block_motion_state = new btDefaultMotionState(data.transform);
		btRigidBody::btRigidBodyConstructionInfo rb_info(data.mass, block_motion_state, single_block, data.local_inertia);
		btRigidBody* body = new btRigidBody(rb_info);

		dynamics_world_->addRigidBody(body);
	}

#pragma endregion

#pragma region DEBUG 用函数

	void PhysicalSimulationApp::test_create_dynamic_rigidbody()
	{
		// 创建测试用的物理物体，这个基本就是对着官方的抄一遍
		btCollisionShape* ground_shape = new btBoxShape(btVector3(btScalar(50.), btScalar(50.), btScalar(50.)));
		collision_shape_array_.push_back(ground_shape);

		btTransform ground_transform;
		ground_transform.setIdentity();
		ground_transform.setOrigin(btVector3(0, -56, 0));

		btScalar mass(0.0f); // 设置地板的质量，小于 0 那它就是静态的

		// 当且仅当质量不是零，刚体是动态的，否则是静态的
		bool is_dynamic = (mass != 0.f);

		btVector3 local_inertia(0, 0, 0);

		if (is_dynamic) ground_shape->calculateLocalInertia(mass, local_inertia);

		// 使用 motionstate 是可选的，它提供插值功能，并且只同步 “活动” 对象
		btDefaultMotionState* my_motion_state = new btDefaultMotionState(ground_transform);
		btRigidBody::btRigidBodyConstructionInfo rbInfo(mass, my_motion_state, ground_shape, local_inertia);
		btRigidBody* body = new btRigidBody(rbInfo);

		// 注册刚体
		dynamics_world_->addRigidBody(body);

		// 创建动态物体
		{
			btCollisionShape* test_cube = new btBoxShape(btVector3(1.0f, 1.0f, 1.0f));
			collision_shape_array_.push_back(test_cube);

			btTransform start_transform;
			start_transform.setIdentity();

			btScalar mass(1.f);
			bool is_dynamic = (mass != 0.f);

			btVector3 local_inertia(0, 0, 0);
			if (is_dynamic) test_cube->calculateLocalInertia(mass, local_inertia);

			start_transform.setOrigin(btVector3(2, 10, 0));

			btDefaultMotionState* my_motion_state = new btDefaultMotionState(start_transform);
			btRigidBody::btRigidBodyConstructionInfo rb_info(mass, my_motion_state, test_cube, local_inertia);
			btRigidBody* body = new btRigidBody(rb_info);

			dynamics_world_->addRigidBody(body);
		}
	}

#pragma endregion

}
